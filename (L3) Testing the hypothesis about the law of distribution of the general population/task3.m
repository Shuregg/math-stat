clc; clear all; format long
X = [13.2412291533284 22.7459361740644 -0.205363009592022 1.05828227443028 -2.72985099725213 10.094231465859 3.47582202566441 4.18025412642885 13.7517283035358 -6.60887647365981 11.489240445001 21.3341359873376 -0.0382875129856135 -4.94976364017314 18.1234877946281 -1.98581279197455 9.65941365588863 13.9442486241863 5.91862991795089 -6.26383153173474 -4.1523902031996 15.7951427334884 9.85479078979673 8.67518658005299 -9.38753013869102 23.6937791323226 -4.69729867111843 6.07388413875055 24.7182564746056 9.59763924989031 7.23660263618077 2.8674007012321 -3.61512853717142 18.6428576378922 -1.06868932457706 -0.70955887246984 4.49343431276244 1.92639851154489 2.10151312286222 -1.56049919172551 7.50830251663972 6.34241338328046 13.2629862553959 -2.71171564866184 8.8702810051634 9.61773883716106 5.66425091377702 8.48840434611646 7.74645207795784 17.7499427207833];
X_sort = sort(X);
 
X_size = size(X); n = max(X_size); x_aver = average(X); n_points = 8;
%в предположении, что массив получен из нормально распределённой генеральной совокупности с
%неизвестными m и σ^2, построить доверительные интервалы
% для математического ожидания и дисперсии при доверительной вероятности, равной 0,95

% H0_1: mx = M0, H0_2: Dx = A0
% 1) X ~ N(m, sigma^2); m, sigma - ? Confidence Intervals for Mx, Dx, 
% P = 0.95 (groupped and ungroupped selection)
alpha = 0.95; %Уровень значимости
[m, sigma, m_int, sigma_int] = normfit(X')

X_linspaced = linspace(X_sort(1), X_sort(length(X_sort)), 8);

absFreq = zeros(1, n_points-1);
for i = 1:1:7
    absFreq(i) = countInRange(X_linspaced(i), X_linspaced(i+1), X_sort);
end

[m_group, sigma_group, m_int_group, sigma_int_group] = normfit(absFreq)
%Функция normfit находит среднее значение выборки и квадратный корень из
%несмещенной оценки дисперсии. По умолчанию alpha = 0.95

% 2) проверить (с помощью построенных доверительных интервалов) гипотезы H0_1: mx = M0, H0_2: Dx = A0 и записать статистическое решение (принять или отклонить нулевую гипотезу);
s = sqrt(var(X, 1));
M0  = x_aver + 0.5 * s
A0 = 2 * s^2

if(m_int(1) <= M0 && M0 <= m_int(2)) %Если M0 в доверительном интервале (m_int), тогда принимаем H0_1
    disp('H0_1 is true: ');
    mess = sprintf('%d in [%d : %d]',M0, m_int(1), m_int(2));
    disp(mess)
else
    disp('H0_1 is false: ');        %Иначе, отвергаем H0_1
    mess = sprintf('M0 = %d not in [%d ; %d]',M0, m_int(1), m_int(2));
    disp(mess)
end

if(sigma_int(1) <= sqrt(A0) && sqrt(A0) <= sigma_int(2)) %Если A0 в доверительном интервале(sigma_int), тогда принимаем H0_2
    disp('H0_2 is true: ');
    mess = sprintf('%d in [%d : %d]',A0, sigma_int(1), sigma_int(2));
    disp(mess)
else
    disp('H0_2 is false: ');
    mess = sprintf('A0 = %d not in [%d ; %d]',A0, sigma_int(1), sigma_int(2));
    disp(mess)
end


